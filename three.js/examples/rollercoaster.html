<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - roller coaster</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			.nav-button {
				position: fixed;
				top: 20px;
				right: 20px;
				width: 160px;
				height: 50px;
				border: 3px solid #000;
				border-radius: 12px;
				cursor: pointer;
				font-family: 'Courier New', monospace;
				font-size: 14px;
				font-weight: bold;
				text-transform: uppercase;
				z-index: 1000;
				transition: all 0.1s ease;
				image-rendering: pixelated;
				text-shadow: 1px 1px 0 #000;
				background: linear-gradient(to bottom, #FFB347 0%, #FF8C00 50%, #FF4500 100%);
				color: #000;
			}
			
			.nav-button:hover {
				transform: translateY(2px);
			}
			
			.nav-button:active {
				transform: translateY(6px);
			}
			
			.loading-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.8);
				display: none;
				justify-content: center;
				align-items: center;
				z-index: 9999;
			}
			
			.loading-spinner {
				width: 60px;
				height: 60px;
				border: 6px solid #f3f3f3;
				border-top: 6px solid #3498db;
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}
			
			@keyframes spin {
				0% { transform: rotate(0deg); }
				100% { transform: rotate(360deg); }
			}
			
			.modal-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.8);
				display: none;
				justify-content: center;
				align-items: center;
				z-index: 10000;
			}
			
			.modal-content {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				border: 4px solid #000;
				border-radius: 15px;
				padding: 30px;
				max-width: 600px;
				width: 90%;
				text-align: center;
				box-shadow: 0 8px 0 #000, inset 0 3px 0 rgba(255, 255, 255, 0.7);
				image-rendering: pixelated;
			}
			
			.modal-title {
				font-family: 'Courier New', monospace;
				font-size: 24px;
				font-weight: bold;
				color: #fff;
				margin-bottom: 20px;
				text-shadow: 2px 2px 0 #000;
				text-transform: uppercase;
			}
			
			.modal-text {
				font-family: 'Courier New', monospace;
				font-size: 16px;
				color: #fff;
				line-height: 1.6;
				margin-bottom: 25px;
				text-shadow: 1px 1px 0 #000;
			}
			
			.modal-button {
				width: 160px;
				height: 50px;
				border: 3px solid #000;
				border-radius: 12px;
				cursor: pointer;
				font-family: 'Courier New', monospace;
				font-size: 14px;
				font-weight: bold;
				text-transform: uppercase;
				transition: all 0.1s ease;
				image-rendering: pixelated;
				text-shadow: 1px 1px 0 #000;
				background: linear-gradient(to bottom, #FFB347 0%, #FF8C00 50%, #FF4500 100%);
				color: #000;
			}
			
			.modal-button:hover {
				transform: translateY(2px);
			}
			
			.modal-button:active {
				transform: translateY(6px);
			}
		</style>
		
		<!-- Arcade button sound -->
		<audio id="arcadeSound" preload="auto">
			<source src="../../button.mp3" type="audio/mpeg">
		</audio>
		
		<script>
			// Arcade button sound function
			function playButtonSound() {
				const audio = document.getElementById('arcadeSound');
				audio.currentTime = 0;
				audio.volume = 0.5;
				audio.play().catch(e => console.log('Audio play failed:', e));
			}
			
			// Show loading overlay
			function showLoading() {
				document.getElementById('loadingOverlay').style.display = 'flex';
			}
			
			// Show modal
			function showModal(title, text) {
				document.getElementById('modalTitle').textContent = title;
				document.getElementById('modalText').textContent = text;
				document.getElementById('modalOverlay').style.display = 'flex';
				window.isModalOpen = true;
				velocity = window.slowVelocity; // Slow down the rollercoaster
			}
			
			// Close modal
			function closeModal() {
				document.getElementById('modalOverlay').style.display = 'none';
				window.isModalOpen = false;
				velocity = window.normalVelocity; // Resume normal speed
				window.currentModalIndex++;
			}
			
			// Check if modal should be triggered
			function checkModalTrigger() {
				if (window.currentModalIndex < window.modalTriggers.length && !window.isModalOpen) {
					const triggerPoint = window.modalTriggers[window.currentModalIndex];
					if (progress >= triggerPoint && progress < triggerPoint + 0.01) {
						const modal = window.roadmapModals[window.currentModalIndex];
						showModal(modal.title, modal.text);
					}
				}
			}
			
			// Add click handlers to all buttons
			document.addEventListener('DOMContentLoaded', function() {
				const buttons = document.querySelectorAll('.nav-button');
				buttons.forEach(button => {
					button.addEventListener('click', function(e) {
						e.preventDefault();
						playButtonSound();
						showLoading();
						
						// Store the original onclick
						const originalOnClick = button.getAttribute('onclick');
						
						// Delay navigation by 1.5 seconds
						setTimeout(() => {
							if (originalOnClick) {
								// Execute the original onclick
								eval(originalOnClick);
							}
						}, 1500);
					});
				});
			});
		</script>
	</head>
	<body>
		<!-- Loading overlay -->
		<div class="loading-overlay" id="loadingOverlay">
			<div class="loading-spinner"></div>
		</div>
		
		<!-- Modal overlay -->
		<div class="modal-overlay" id="modalOverlay">
			<div class="modal-content">
				<div class="modal-title" id="modalTitle">ABSTRACT ROADMAP</div>
				<div class="modal-text" id="modalText">Bienvenido al futuro del metaverso...</div>
				<button class="modal-button" onclick="closeModal()">ACEPTAR</button>
			</div>
		</div>
		
		<button class="nav-button" onclick="window.location.href='city.html'">return to the city</button>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import {
				RollerCoasterGeometry,
				RollerCoasterShadowGeometry,
				RollerCoasterLiftersGeometry,
				TreesGeometry,
				SkyGeometry
			} from 'three/addons/misc/RollerCoaster.js';

			// import { VRButton } from 'three/addons/webxr/VRButton.js';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

			let mesh, material, geometry;

			// Initialize animation variables
			let velocity = 0.0001; // Start with normal velocity
			let progress = 0;
			let prevTime = performance.now();
			
			// Modal system variables - moved to global scope
			window.isModalOpen = false;
			window.currentModalIndex = 0;
			window.normalVelocity = 0.0001;
			window.slowVelocity = 0.00001;
			
			// Roadmap modals data - moved to global scope
			window.roadmapModals = [
				{
					title: "ABSTRACT TOKEN",
					text: "Bienvenido a ABSTRACT, un token revolucionario en Abstract MoonShot. Sabemos que no es perfecto, pero queremos mostraros el potencial que tenemos para crear algo extraordinario."
				},
				{
					title: "METAVERSO AUTÉNTICO",
					text: "Nuestro objetivo es crear el metaverso más auténtico de ABSTRACT, inspirado en el estilo GTA V Role Play, donde cada jugador tendrá su propia profesión y podrá hacer trading dentro del juego."
				},
				{
					title: "PROFESIONES Y TRADING",
					text: "Cada jugador podrá elegir su profesión: policía, médico, comerciante, constructor, etc. Todas las transacciones se realizarán con tokens ABSTRACT dentro del metaverso."
				},
				{
					title: "ECONOMÍA VIRTUAL",
					text: "Crearemos una economía virtual completa donde los jugadores pueden comprar propiedades, vehículos, negocios y más, todo usando tokens ABSTRACT."
				},
				{
					title: "COMUNIDAD Y DESARROLLO",
					text: "Este es solo el comienzo. Con el apoyo de nuestra comunidad, construiremos juntos el metaverso más innovador y auténtico del mundo crypto."
				}
			];
			
			// Modal trigger points (progress values where modals should appear) - moved to global scope
			window.modalTriggers = [0.1, 0.25, 0.4, 0.6, 0.8];
			
			// Initialize vectors for animation
			const position = new THREE.Vector3();
			const tangent = new THREE.Vector3();
			const lookAt = new THREE.Vector3();

			const renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: true, colorBufferType: THREE.UnsignedByteType, multiview: false } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			// renderer.xr.enabled = true;
			// renderer.xr.setReferenceSpaceType( 'local' );
			document.body.appendChild( renderer.domElement );

			// document.body.appendChild( VRButton.createButton( renderer ) );

			//

			const scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xf0f0ff );

			const light = new THREE.HemisphereLight( 0xfff0f0, 0x60606, 3 );
			light.position.set( 1, 1, 1 );
			scene.add( light );

			const train = new THREE.Object3D();
			scene.add( train );

			const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 500 );
			train.add( camera );

			// environment

			geometry = new THREE.PlaneGeometry( 500, 500, 15, 15 );
			geometry.rotateX( - Math.PI / 2 );

			const positions = geometry.attributes.position.array;
			const vertex = new THREE.Vector3();

			for ( let i = 0; i < positions.length; i += 3 ) {

				vertex.fromArray( positions, i );

				vertex.x += Math.random() * 10 - 5;
				vertex.z += Math.random() * 10 - 5;

				const distance = ( vertex.distanceTo( scene.position ) / 5 ) - 25;
				vertex.y = Math.random() * Math.max( 0, distance );

				vertex.toArray( positions, i );

			}

			geometry.computeVertexNormals();

			material = new THREE.MeshLambertMaterial( {
				color: 0x407000
			} );

			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new TreesGeometry( mesh );
			material = new THREE.MeshBasicMaterial( {
				side: THREE.DoubleSide, vertexColors: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new SkyGeometry();
			material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			//

			const PI2 = Math.PI * 2;

			const curve = ( function () {

				const vector = new THREE.Vector3();
				const vector2 = new THREE.Vector3();

				return {

					getPointAt: function ( t ) {

						t = t * PI2;

						const x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;
						const y = Math.sin( t * 10 ) * 2 + Math.cos( t * 17 ) * 2 + 5;
						const z = Math.sin( t ) * Math.sin( t * 4 ) * 50;

						return vector.set( x, y, z ).multiplyScalar( 2 );

					},

					getTangentAt: function ( t ) {

						const delta = 0.0001;
						const t1 = Math.max( 0, t - delta );
						const t2 = Math.min( 1, t + delta );

						return vector2.copy( this.getPointAt( t2 ) )
							.sub( this.getPointAt( t1 ) ).normalize();

					}

				};

			} )();

			geometry = new RollerCoasterGeometry( curve, 1500 );
			material = new THREE.MeshPhongMaterial( {
				vertexColors: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new RollerCoasterLiftersGeometry( curve, 100 );
			material = new THREE.MeshPhongMaterial();
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 0.1;
			scene.add( mesh );

			geometry = new RollerCoasterShadowGeometry( curve, 500 );
			material = new THREE.MeshBasicMaterial( {
				color: 0x305000, depthWrite: false, transparent: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 0.1;
			scene.add( mesh );

			const funfairs = [];

			//

			// Create floating ABSTRACT text that rotates
			const treeGroup = new THREE.Group();
			
			// Load font and create 3D text
			const loader = new FontLoader();
			loader.load( 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function ( font ) {
				
				const textGeometry = new TextGeometry( 'ABSTRACT', {
					font: font,
					size: 2,
					height: 0.1,
					curveSegments: 8,
					bevelEnabled: false
				} );
				
				textGeometry.computeBoundingBox();
				const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
				
				const textMaterial = new THREE.MeshLambertMaterial( { color: 0x228B22 } );
				const textMesh = new THREE.Mesh( textGeometry, textMaterial );
				
				// Center the text above the trunk
				textMesh.position.set( -textWidth / 2, 20, 0 );
				treeGroup.add( textMesh );
				
			} );
			
			treeGroup.position.set( -80, 0, -70 );
			scene.add( treeGroup );
			funfairs.push( treeGroup );

			//

			window.addEventListener( 'resize', onWindowResize );

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				const time = performance.now();
				const delta = time - prevTime;

				for ( let i = 0; i < funfairs.length; i ++ ) {

					funfairs[ i ].rotation.y = time * 0.0004;

				}

				//

				progress += velocity;
				progress = progress % 1;

				position.copy( curve.getPointAt( progress ) );
				position.y += 0.3;

				train.position.copy( position );

				tangent.copy( curve.getTangentAt( progress ) );

				// Only apply gravity when no modal is open
				if (!window.isModalOpen) {
					velocity -= tangent.y * 0.0000001 * delta;
					velocity = Math.max( 0.00004, Math.min( 0.0002, velocity ) );
				}

				train.lookAt( lookAt.copy( position ).sub( tangent ) );

				// Check for modal triggers
				checkModalTrigger();

				//

				renderer.render( scene, camera );

				prevTime = time;

			}

		</script>

	</body>
</html>
